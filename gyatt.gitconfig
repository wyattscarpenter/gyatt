# This is gyatt. See https://github.com/wyattscarpenter/gyatt
# If you modify any of these lines (without making a pull request with the new changes to gyatt (or, I suppose, removing these comment lines so that this file no longer claims to be gyatt)), then for your own sake as well as mine I recommend you leave a comment by the option with YOUR NAME and why you've done what you've done. This will help you later if you need to locate problems.
# This file is alphabetized for quick reference (normal gitconfig files are not alphabetized — they are simply in whatever chronological order the options were set from the command line — but this one was written by hand, so I did alphabetize it). First by section, then within each section by each option. This means you will probably want to skip past the [alias] section at first to check out the options at the bottom, which are likely to be more important to you.
[alias]
	abandon = reset --hard @{upstream} #abandon the local copy and switch to origin
	amend = git commit -a --amend --no-edit #this also amends unstaged changes, which is what I want half the time, but half the time is not what I want.
	b = branch --verbose
	be = ! git-be
	br = b
	blast = ! git-blast
	c = commit # TODO: I kind of regret having this alias bc it's easy to confuse with checkout so I don't use git c often. So maybe remove it later.
	cd = checkout
	ch = checkout
	check = ! git diff --staged --check && git diff --check && git diff --check $(git hash-object -t tree /dev/null) # Like git diff --check but for everything (although note that it will only report further errors once you've dealt with what's staged, then what's changed, then finally it will report on everything that's tracked). # Thanks be to http://peter.eisentraut.org/blog/2014/11/04/checking-whitespace-with-git #TODO /  Pet peeve unlocked: git will complain at you if you commit a file that has no new line at the end of the file; but it will not warn about this in git diff --check
	cherrypick = cherry-pick
	chmod = ! git-chmod
	chomd = chmod
	conforg = config --show-origin
	cp = cherry-pick # I might regret this alias later, since cp can also mean "copy", and there's, like, a git mv already that a git cp could exist in analogy to.
	d = diff --word-diff=color
	dugc = ! du --summarize --human-readable --block-size=MiB . && git gc --aggressive && du --summarize --human-readable --block-size=MiB .
	f = fetch --all
	fg = ! git f && git g # Not to be confused with the fg command of the unix world.
	fgg = ! git f && git gg # For some reason all of {fg, fgg, fggg} seem to do fgg? Also, on git for windows at least, it seems f doesn't print any output.
	fggg = ! git f && git ggg
	find-and-replace = !git grep -I --name-only "$1" | xargs sed -i "s/$1/$2/g"
	forsake = abandon
	g = ! git log --all --graph --pretty=format:'%C(bold blue)%as %Cgreen%ad%Creset %C(auto)%h%d %s %C(bold black)<%aN>%Creset' --date=format-local:'%H:%M (%a)' #format inspired by https://gist.github.com/niun/ca61a37791ff1fdc9b33 # The ! git part is necessary, or else this does not work on Windows (replacing with double quotes will not cure the problem either). # I later decided to add a unix call as well for the net loc
	gg = g -20 # Although the number 20 is fundamentally arbitrary here, and is chosen mostly just to comfortably fit in a default cmd window; and g is arbitrary and I just wanted to type it twice for fast typing; I like to amuse myself by pretending there is some great and noble correspondence between g, giga-, billion, twice million, and 20. Although my case is weakened by the fact that a mebi is 2^20, which is an even twentier number.
	ggg = g -40
	git = ! git # handles the ever-so-important `git git` case. Might fail (or do something unexpected) if you have git renamed to something else, I guess.
	l = log
	ll = log -5
	ln = ! f() { ln -s "$@"; git add "$@" } f #this will also git add the non-link file; if you don't want this, don't use this git-ln script! #TODO: untested; not sure about the function syntax
	ls = git-ls #this one should probably get a different alias idk
	move = reset --hard # The idea here is that you move the head (and current branch tip ref, naturally) to the specified commit.
	nocheckin = ! git-nocheckin # this sets up the nocheckin *system*. as opposed to git nocheckins, which checks for *tokens* of nocheckin
	nocheckins = git diff --staged -i --diff-filter=d -G "no""checkin" # Checks for the existence of the forbidden string
	netloc = ! git-netloc
	obv = ! git-obv # Honestly I don't know why we can't just put this script in this line directly. But it gives us "fatal: bad config line", at least in git version 2.45.2.windows.1
	po = push --set-upstream origin HEAD
	pfush = push --force-with-lease --force-if-includes # the safest type of force push
	pffush = push --force-with-lease # the second-safest type of force push
	r = remote -v
	reb = rebase
	rebcont = ! git add -u && git -c core.editor=true rebase --continue # continue a rebase or merge without editing the message. See https://stackoverflow.com/questions/43489971/how-to-suppress-the-editor-for-git-rebase-continue
	rebforsake = ! git checkout --theirs . && git rebcont #todo: also make mergecont and mergeforsake?
	remove-from-history = ! git-remove-from-history #todo: can this be inlined here?
	replace-all-in-history = ! git-replace-all-in-history #todo: can this be inlined here?
	s = status
	st = status
	statuses = ! gits-status # todo: I should have a consistent rule on if I include aliases that would also be scripts added to path. For example, git-obv being both a script that git would find if you add the gyatt folder to the path and also an alias to said script, listed above. This comes to attention here because I'd like this to be both git-statuses and gits-status, the later of which won't be found on path by git. But this is an easy todo, really. (Currently, my answer is "yes", but I should ponder if my answer should be "no" for DRY or other reasons.)
	sh = show --word-diff=color #also might regret this alias one day as sh is also a shell.
	signoff = ! git-signoff # I get a mysterious "end-of-file" error if I try to inline this.
	t = tag
	touch = ! touch "$@" && git add "$@"
	touchx = ! touch "$@" && git add --chmod=+x "$@"
	w = whoami
	whoami = ! git config --get user.name && git config --get user.email
[commit]
	verbose = true
[credential]
	useHttpPath = true
[diff]
	wsErrorHighlight = all
[init]
	defaultBranch = master
[rerere]
	enabled = true
